rs
plot(pnorm(rs))
plot(pnorm(rs), type="l")
pnorm(rs)
round(pnorm(rs), 3)
Q
metaLik.prof <- function(object, param=1, level=0.95, plot=TRUE, ...){    if(class(object)!="metaLik")        stop("function designed for 'metaLik' objects")    if(length(param)>1 || param>=length(object$mle) || !is.numeric(param))        stop("'param' must be the index of one single fixed-effects component")    if (missing(param)){        param <- 1        warning("assumed confidence interval for intercept")    }    par.mle <- object$mle[param]    se.mle <- sqrt(object$vcov[param, param])    values <- seq(from=par.mle-10*se.mle, to=par.mle+10*se.mle, length=200)    rs <- rskovs <- rep(NA, length(values))    for(i in 1:length(values)){        tests <- metaLik.test(object, param, values[i], print=FALSE)        rs[i] <- tests["rtheta"]        rskovs[i] <- tests["rskov"]    }        par.name <- names(coef(object))[param]    res <- structure(list(rs=rs, rskovs=rskovs))    res}
metaLik.prof(m, 1)
metaLik.prof(m, 1)-> a
a$rs
plot(a$rs)
qqnorm(ecdf(a$rs)(a$rs))
qqnorm(qnorm(ecdf(a$rs)(a$rs)))
ecdf(a$rs)(a$rs)
hist(a$rs)
a$rs
ecdf(a$rs)(a$rs)
ecdf(a$rs)
ecdf(a$rs,plot=T)
ecdf(a$rs)
pnorm(a$rs)
uniroot(pnorm(a$rs)-1.96)
uniroot(pnorm(a$rs)-1.96, interval=c(-10, 10))
smooth.spline
help(smooth.spline)
metaLik.prof <- function(object, param=1, level=0.95, plot=TRUE, ...){    if(class(object)!="metaLik")        stop("function designed for 'metaLik' objects")    if(length(param)>1 || param>=length(object$mle) || !is.numeric(param))        stop("'param' must be the index of one single fixed-effects component")    if (missing(param)){        param <- 1        warning("assumed confidence interval for intercept")    }    par.mle <- object$mle[param]    se.mle <- sqrt(object$vcov[param, param])    values <- seq(from=par.mle-10*se.mle, to=par.mle+10*se.mle, length=200)    rs <- rskovs <- rep(NA, length(values))    for(i in 1:length(values)){        tests <- metaLik.test(object, param, values[i], print=FALSE)        rs[i] <- tests["rtheta"]        rskovs[i] <- tests["rskov"]    }    smooth.r <- smooth.spline(-rs, values)    smooth.rskov <- smooth.spline(-rskov, values)    lo.r <- predict(smooth.r, x=qnorm((1-level)/2))$y    up.r <- predict(smooth.r, x=qnorm((1+level)/2))$y    lo.rskov <- pre
dict(smooth.rskov, x=qnorm((1-level)/2))$y    up.rskov <- predict(smooth.rskov, x=qnorm((1+level)/2))$y    par.name <- names(coef(object))[param]    res <- structure(list(rthetas=rs, rskovs=rskovs, lower.rtheta=lo.r, upper.rtheta=up.r, lower.rskov=lo.rskov, upper.rskov=up.rskov))    invisble(res)}
metaLik.prof(m, 1)-> a
metaLik.prof <- function(object, param=1, level=0.95, plot=TRUE, ...){    if(class(object)!="metaLik")        stop("function designed for 'metaLik' objects")    if(length(param)>1 || param>=length(object$mle) || !is.numeric(param))        stop("'param' must be the index of one single fixed-effects component")    if (missing(param)){        param <- 1        warning("assumed confidence interval for intercept")    }    par.mle <- object$mle[param]    se.mle <- sqrt(object$vcov[param, param])    values <- seq(from=par.mle-10*se.mle, to=par.mle+10*se.mle, length=200)    rs <- rskovs <- rep(NA, length(values))    for(i in 1:length(values)){        tests <- metaLik.test(object, param, values[i], print=FALSE)        rs[i] <- tests["rtheta"]        rskovs[i] <- tests["rskov"]    }    smooth.r <- smooth.spline(-rs, values)    smooth.rskov <- smooth.spline(-rskovs, values)    lo.r <- predict(smooth.r, x=qnorm((1-level)/2))$y    up.r <- predict(smooth.r, x=qnorm((1+level)/2))$y    lo.rskov <- pr
edict(smooth.rskov, x=qnorm((1-level)/2))$y    up.rskov <- predict(smooth.rskov, x=qnorm((1+level)/2))$y    par.name <- names(coef(object))[param]    res <- structure(list(rthetas=rs, rskovs=rskovs, lower.rtheta=lo.r, upper.rtheta=up.r, lower.rskov=lo.rskov, upper.rskov=up.rskov))    invisble(res)}
metaLik.prof(m, 1)-> a
metaLik.prof <- function(object, param=1, level=0.95, plot=TRUE, ...){    if(class(object)!="metaLik")        stop("function designed for 'metaLik' objects")    if(length(param)>1 || param>=length(object$mle) || !is.numeric(param))        stop("'param' must be the index of one single fixed-effects component")    if (missing(param)){        param <- 1        warning("assumed confidence interval for intercept")    }    par.mle <- object$mle[param]    se.mle <- sqrt(object$vcov[param, param])    values <- seq(from=par.mle-10*se.mle, to=par.mle+10*se.mle, length=200)    rs <- rskovs <- rep(NA, length(values))    for(i in 1:length(values)){        tests <- metaLik.test(object, param, values[i], print=FALSE)        rs[i] <- tests["rtheta"]        rskovs[i] <- tests["rskov"]    }    smooth.r <- smooth.spline(-rs, values)    smooth.rskov <- smooth.spline(-rskovs, values)    lo.r <- predict(smooth.r, x=qnorm((1-level)/2))$y    up.r <- predict(smooth.r, x=qnorm((1+level)/2))$y    lo.rskov <- pr
edict(smooth.rskov, x=qnorm((1-level)/2))$y    up.rskov <- predict(smooth.rskov, x=qnorm((1+level)/2))$y    par.name <- names(coef(object))[param]    res <- structure(list(rthetas=rs, rskovs=rskovs, lower.rtheta=lo.r, upper.rtheta=up.r, lower.rskov=lo.rskov, upper.rskov=up.rskov))    invisible(res)}
metaLik.prof(m, 1)-> a
a
metaLik.prof(m, 2)-> a
m
metaLik.prof <- function(object, param=1, level=0.95, plot=TRUE, ...){    if(class(object)!="metaLik")        stop("function designed for 'metaLik' objects")    if(length(param)>1 || param>=length(object$mle) || !is.numeric(param))        stop("'param' must be the index of one single fixed-effects component")    if (missing(param)){        param <- 1        warning("assumed confidence interval for intercept")    }    par.mle <- object$mle[param]    se.mle <- sqrt(object$vcov[param, param])    values <- seq(from=par.mle-5*se.mle, to=par.mle+5*se.mle, length=20)    rs <- rskovs <- rep(NA, length(values))    for(i in 1:length(values)){        tests <- metaLik.test(object, param, values[i], print=FALSE)        rs[i] <- tests["rtheta"]        rskovs[i] <- tests["rskov"]    }    smooth.r <- smooth.spline(-rs, values)    smooth.rskov <- smooth.spline(-rskovs, values)    lo.r <- predict(smooth.r, x=qnorm((1-level)/2))$y    up.r <- predict(smooth.r, x=qnorm((1+level)/2))$y    lo.rskov <- predi
ct(smooth.rskov, x=qnorm((1-level)/2))$y    up.rskov <- predict(smooth.rskov, x=qnorm((1+level)/2))$y    par.name <- names(coef(object))[param]    res <- structure(list(rthetas=rs, rskovs=rskovs, lower.rtheta=lo.r, upper.rtheta=up.r, lower.rskov=lo.rskov, upper.rskov=up.rskov))    invisible(res)}
metaLik.prof(m, 2)-> a
debug(metaLik.prof)
metaLik.prof(m, 2)-> a
par.mle
se.mle
c
mr
mrtruefit
mr::.mrtruefit
mr:::mrtruefit
mr:::mrloglik
help(inherits)
metaLik.prof <- function(object, param=1, level=0.95, plot=TRUE, ...){    if(class(object)!="metaLik")        stop("function designed for 'metaLik' objects")    if(length(param)>1 || param>=length(object$mle) || !is.numeric(param))        stop("'param' must be the index of one single fixed-effects component")    if (missing(param)){        param <- 1        warning("assumed confidence interval for intercept")    }    par.mle <- object$mle[param]    se.mle <- sqrt(object$vcov[param, param])    values <- seq(from=par.mle-5*se.mle, to=par.mle+5*se.mle, length=30)    rs <- rskovs <- rep(NA, length(values))    for(i in 1:length(values)){        tests <- try(metaLik.test(object, param, values[i], print=FALSE))        if(!inherits(tests, "try-error")){            rs[i] <- tests["rtheta"]            rskovs[i] <- tests["rskov"]        }    }    smooth.r <- smooth.spline(-rs, values)    smooth.rskov <- smooth.spline(-rskovs, values)    lo.r <- predict(smooth.r, x=qnorm((1-level)/2))$y    up.r
<- predict(smooth.r, x=qnorm((1+level)/2))$y    lo.rskov <- predict(smooth.rskov, x=qnorm((1-level)/2))$y    up.rskov <- predict(smooth.rskov, x=qnorm((1+level)/2))$y    par.name <- names(coef(object))[param]    res <- structure(list(rthetas=rs, rskovs=rskovs, lower.rtheta=lo.r, upper.rtheta=up.r, lower.rskov=lo.rskov, upper.rskov=up.rskov))    invisible(res)}
metaLik.prof(m, 2)-> a
a
metaLik.prof <- function(object, param=1, level=0.95, plot=TRUE, ...){    if(class(object)!="metaLik")        stop("function designed for 'metaLik' objects")    if(length(param)>1 || param>=length(object$mle) || !is.numeric(param))        stop("'param' must be the index of one single fixed-effects component")    if (missing(param)){        param <- 1        warning("assumed confidence interval for intercept")    }    par.mle <- object$mle[param]    se.mle <- sqrt(object$vcov[param, param])    values <- seq(from=par.mle-10*se.mle, to=par.mle+10*se.mle, length=30)    rs <- rskovs <- rep(NA, length(values))    for(i in 1:length(values)){        tests <- try(metaLik.test(object, param, values[i], print=FALSE))        if(!inherits(tests, "try-error")){            rs[i] <- tests["rtheta"]            rskovs[i] <- tests["rskov"]        }    }    smooth.r <- smooth.spline(-rs, values)    smooth.rskov <- smooth.spline(-rskovs, values)    lo.r <- predict(smooth.r, x=qnorm((1-level)/2))$y    up.
r <- predict(smooth.r, x=qnorm((1+level)/2))$y    lo.rskov <- predict(smooth.rskov, x=qnorm((1-level)/2))$y    up.rskov <- predict(smooth.rskov, x=qnorm((1+level)/2))$y    par.name <- names(coef(object))[param]    res <- structure(list(rthetas=rs, rskovs=rskovs, lower.rtheta=lo.r, upper.rtheta=up.r, lower.rskov=lo.rskov, upper.rskov=up.rskov))    invisible(res)}
metaLik.prof(m, 2)-> a
a
metaLik.prof <- function(object, param=1, level=0.95, plot=TRUE, ...){    if(class(object)!="metaLik")        stop("function designed for 'metaLik' objects")    if(length(param)>1 || param>=length(object$mle) || !is.numeric(param))        stop("'param' must be the index of one single fixed-effects component")    if (missing(param)){        param <- 1        warning("assumed confidence interval for intercept")    }    par.mle <- object$mle[param]    se.mle <- sqrt(object$vcov[param, param])    values <- seq(from=par.mle-10*se.mle, to=par.mle+10*se.mle, length=40)    rs <- rskovs <- rep(NA, length(values))    for(i in 1:length(values)){        tests <- try(metaLik.test(object, param, values[i], print=FALSE))        if(!inherits(tests, "try-error")){            rs[i] <- tests["rtheta"]            rskovs[i] <- tests["rskov"]        }    }    smooth.r <- smooth.spline(-rs, values)    smooth.rskov <- smooth.spline(-rskovs, values)    lo.r <- predict(smooth.r, x=qnorm((1-level)/2))$y    up.
r <- predict(smooth.r, x=qnorm((1+level)/2))$y    lo.rskov <- predict(smooth.rskov, x=qnorm((1-level)/2))$y    up.rskov <- predict(smooth.rskov, x=qnorm((1+level)/2))$y    par.name <- names(coef(object))[param]    res <- structure(list(rthetas=rs, rskovs=rskovs, lower.rtheta=lo.r, upper.rtheta=up.r, lower.rskov=lo.rskov, upper.rskov=up.rskov))    invisible(res)}
metaLik.prof(m, 2)-> a
a
metaLik.prof <- function(object, param=1, level=0.95, plot=TRUE, ...){    if(class(object)!="metaLik")        stop("function designed for 'metaLik' objects")    if(length(param)>1 || param>=length(object$mle) || !is.numeric(param))        stop("'param' must be the index of one single fixed-effects component")    if (missing(param)){        param <- 1        warning("assumed confidence interval for intercept")    }    par.mle <- object$mle[param]    se.mle <- sqrt(object$vcov[param, param])    values <- seq(from=par.mle-10*se.mle, to=par.mle+10*se.mle, length=30)    rs <- rskovs <- rep(NA, length(values))    for(i in 1:length(values)){        tests <- try(metaLik.test(object, param, values[i], print=FALSE))        if(!inherits(tests, "try-error")){            rs[i] <- tests["rtheta"]            rskovs[i] <- tests["rskov"]        }    }    smooth.r <- smooth.spline(-rs, values)    smooth.rskov <- smooth.spline(-rskovs, values)    lo.r <- predict(smooth.r, x=qnorm((1-level)/2))$y    up.
r <- predict(smooth.r, x=qnorm((1+level)/2))$y    lo.rskov <- predict(smooth.rskov, x=qnorm((1-level)/2))$y    up.rskov <- predict(smooth.rskov, x=qnorm((1+level)/2))$y    par.name <- names(coef(object))[param]    if(plot){        plot(smooth.spline(values, -rs), type="l")        lines(smooth.spline(values, -rskovs), col="red")            }        res <- structure(list(rthetas=rs, rskovs=rskovs, lower.rtheta=lo.r, upper.rtheta=up.r, lower.rskov=lo.rskov, upper.rskov=up.rskov))    invisible(res)}
metaLik.prof(m, 2)-> a
a
segments(a$lower.rtheta, 0)
segments(a$lower.rtheta,0, a$lower.rtheta, 1)
qnorm(a$rs)
pnorm(a$rs)
round(pnorm(a$rs), 3)
round(pnorm(-a$rs), 3)
qnorm(0.025)
segments(a$lower.rtheta, min(a$rs, a$rskovs), a$lower.rtheta, 1.96)
segments(a$lower.rtheta, min(a$rs, a$rskovs), a$lower.rtheta, -1.96)
segments(a$lower.rtheta, min(a$rs, a$rskovs), a$lower.rtheta, -1.96, col="green")
segments(a$lower.rtheta, -6, a$lower.rtheta, -1.96, col="green")
segments(a$upper.rtheta, -6, a$upper.rtheta, 1.96, col="green")
segments(a$lower.rskov, -6, a$lower.rskov, -1.96, col="blue")
segments(a$upper.rskov, -6, a$upper.rskov, 1.96, col="blue")
segments(a$upper.rskov, -Inf, a$upper.rskov, 1.96, col="blue")
metaLik.prof(m, 2)-> a
segments(a$upper.rskov, -Inf, a$upper.rskov, 1.96, col="blue")
range(ylim)
ylim
help(segments)
metaLik.prof <- function(object, param=1, level=0.95, plot=TRUE, ...){    if(class(object)!="metaLik")        stop("function designed for 'metaLik' objects")    if(length(param)>1 || param>=length(object$mle) || !is.numeric(param))        stop("'param' must be the index of one single fixed-effects component")    if (missing(param)){        param <- 1        warning("assumed confidence interval for intercept")    }    par.mle <- object$mle[param]    se.mle <- sqrt(object$vcov[param, param])    values <- seq(from=par.mle-10*se.mle, to=par.mle+10*se.mle, length=30)    rs <- rskovs <- rep(NA, length(values))    for(i in 1:length(values)){        tests <- try(metaLik.test(object, param, values[i], print=FALSE))        if(!inherits(tests, "try-error")){            rs[i] <- tests["rtheta"]            rskovs[i] <- tests["rskov"]        }    }    smooth.r <- smooth.spline(-rs, values)    smooth.rskov <- smooth.spline(-rskovs, values)    lo.r <- predict(smooth.r, x=qnorm((1-level)/2))$y    up.
r <- predict(smooth.r, x=qnorm((1+level)/2))$y    lo.rskov <- predict(smooth.rskov, x=qnorm((1-level)/2))$y    up.rskov <- predict(smooth.rskov, x=qnorm((1+level)/2))$y    par.name <- names(coef(object))[param]    if(plot){        plot(smooth.spline(values, -rs), type="l", ylim=c(min(rs, rskovs), max(rs, rskovs)))        lines(smooth.spline(values, -rskovs), col="red")        segments(a$lower.rtheta, min(a$rs, a$rskovs), a$lower.rtheta, qnorm((1-level)/2), lty=2)        segments(a$upper.rtheta, min(a$rs, a$rskovs), a$upper.rtheta, qnorm((1+level)/2), lty=2)        segments(a$lower.rskov, min(a$rs, a$rskovs), a$lower.rskov, qnorm((1-level)/2), lty=2, col="red")        segments(a$upper.rskov, min(a$rs, a$rskovs), a$upper.rskov, qnorm((1+level)/2), lty=2, col"red")    }        res <- structure(list(rthetas=rs, rskovs=rskovs, lower.rtheta=lo.r, upper.rtheta=up.r, lower.rskov=lo.rskov, upper.rskov=up.rskov))    invisible(res)}
help(segments)
metaLik.prof <- function(object, param=1, level=0.95, plot=TRUE, ...){    if(class(object)!="metaLik")        stop("function designed for 'metaLik' objects")    if(length(param)>1 || param>=length(object$mle) || !is.numeric(param))        stop("'param' must be the index of one single fixed-effects component")    if (missing(param)){        param <- 1        warning("assumed confidence interval for intercept")    }    par.mle <- object$mle[param]    se.mle <- sqrt(object$vcov[param, param])    values <- seq(from=par.mle-10*se.mle, to=par.mle+10*se.mle, length=30)    rs <- rskovs <- rep(NA, length(values))    for(i in 1:length(values)){        tests <- try(metaLik.test(object, param, values[i], print=FALSE))        if(!inherits(tests, "try-error")){            rs[i] <- tests["rtheta"]            rskovs[i] <- tests["rskov"]        }    }    smooth.r <- smooth.spline(-rs, values)    smooth.rskov <- smooth.spline(-rskovs, values)    lo.r <- predict(smooth.r, x=qnorm((1-level)/2))$y    up.
r <- predict(smooth.r, x=qnorm((1+level)/2))$y    lo.rskov <- predict(smooth.rskov, x=qnorm((1-level)/2))$y    up.rskov <- predict(smooth.rskov, x=qnorm((1+level)/2))$y    par.name <- names(coef(object))[param]    if(plot){        plot(smooth.spline(values, -rs), type="l", ylim=c(min(rs, rskovs), max(rs, rskovs)))        lines(smooth.spline(values, -rskovs), col="red")        segments(a$lower.rtheta, min(a$rs, a$rskovs), a$lower.rtheta, qnorm((1-level)/2), lty=2)        segments(a$upper.rtheta, min(a$rs, a$rskovs), a$upper.rtheta, qnorm((1+level)/2), lty=2)        segments(a$lower.rskov, min(a$rs, a$rskovs), a$lower.rskov, qnorm((1-level)/2), lty=2, col="red")        segments(a$upper.rskov, min(a$rs, a$rskovs), a$upper.rskov, qnorm((1+level)/2), lty=2, col"red")    }        res <- structure(list(rthetas=rs, rskovs=rskovs, lower.rtheta=lo.r, upper.rtheta=up.r, lower.rskov=lo.rskov, upper.rskov=up.rskov))    invisible(res)}
metaLik.prof <- function(object, param=1, level=0.95, plot=TRUE, ...){    if(class(object)!="metaLik")        stop("function designed for 'metaLik' objects")    if(length(param)>1 || param>=length(object$mle) || !is.numeric(param))        stop("'param' must be the index of one single fixed-effects component")    if (missing(param)){        param <- 1        warning("assumed confidence interval for intercept")    }    par.mle <- object$mle[param]    se.mle <- sqrt(object$vcov[param, param])    values <- seq(from=par.mle-10*se.mle, to=par.mle+10*se.mle, length=30)    rs <- rskovs <- rep(NA, length(values))    for(i in 1:length(values)){        tests <- try(metaLik.test(object, param, values[i], print=FALSE))        if(!inherits(tests, "try-error")){            rs[i] <- tests["rtheta"]            rskovs[i] <- tests["rskov"]        }    }    smooth.r <- smooth.spline(-rs, values)    smooth.rskov <- smooth.spline(-rskovs, values)    lo.r <- predict(smooth.r, x=qnorm((1-level)/2))$y    up.
r <- predict(smooth.r, x=qnorm((1+level)/2))$y    lo.rskov <- predict(smooth.rskov, x=qnorm((1-level)/2))$y    up.rskov <- predict(smooth.rskov, x=qnorm((1+level)/2))$y    par.name <- names(coef(object))[param]    if(plot){        plot(smooth.spline(values, -rs), type="l", ylim=c(min(rs, rskovs), max(rs, rskovs)))        lines(smooth.spline(values, -rskovs), col="red")        segments(a$lower.rtheta, min(a$rs, a$rskovs), a$lower.rtheta, qnorm((1-level)/2), lty=2)        segments(a$upper.rtheta, min(a$rs, a$rskovs), a$upper.rtheta, qnorm((1+level)/2), lty=2)        segments(a$lower.rskov, min(a$rs, a$rskovs), a$lower.rskov, qnorm((1-level)/2), lty=2, col="red")        segments(a$upper.rskov, min(a$rs, a$rskovs), a$upper.rskov, qnorm((1+level)/2), lty=2, col="red")    }        res <- structure(list(rthetas=rs, rskovs=rskovs, lower.rtheta=lo.r, upper.rtheta=up.r, lower.rskov=lo.rskov, upper.rskov=up.rskov))    invisible(res)}
metaLik.prof(m, 2)-> a
a
metaLik.prof <- function(object, param=1, level=0.95, plot=TRUE, ...){    if(class(object)!="metaLik")        stop("function designed for 'metaLik' objects")    if(length(param)>1 || param>=length(object$mle) || !is.numeric(param))        stop("'param' must be the index of one single fixed-effects component")    if (missing(param)){        param <- 1        warning("assumed confidence interval for intercept")    }    par.mle <- object$mle[param]    se.mle <- sqrt(object$vcov[param, param])    values <- seq(from=par.mle-10*se.mle, to=par.mle+10*se.mle, length=30)    rs <- rskovs <- rep(NA, length(values))    for(i in 1:length(values)){        tests <- try(metaLik.test(object, param, values[i], print=FALSE))        if(!inherits(tests, "try-error")){            rs[i] <- tests["rtheta"]            rskovs[i] <- tests["rskov"]        }    }    smooth.r <- smooth.spline(-rs, values)    smooth.rskov <- smooth.spline(-rskovs, values)    lo.r <- predict(smooth.r, x=qnorm((1-level)/2))$y    up.
r <- predict(smooth.r, x=qnorm((1+level)/2))$y    lo.rskov <- predict(smooth.rskov, x=qnorm((1-level)/2))$y    up.rskov <- predict(smooth.rskov, x=qnorm((1+level)/2))$y    par.name <- names(coef(object))[param]    if(plot){        plot(smooth.spline(values, -rs), type="l", ylim=c(min(rs, rskovs), max(rs, rskovs)), ylab="signed profile log-likelihood ratio", xlab="parameter")        lines(smooth.spline(values, -rskovs), col="red")        segments(a$lower.rtheta, min(a$rs, a$rskovs)-10, a$lower.rtheta, qnorm((1-level)/2), lty=2)        segments(a$upper.rtheta, min(a$rs, a$rskovs)-10, a$upper.rtheta, qnorm((1+level)/2), lty=2)        segments(a$lower.rskov, min(a$rs, a$rskovs)-10, a$lower.rskov, qnorm((1-level)/2), lty=2, col="red")        segments(a$upper.rskov, min(a$rs, a$rskovs)-10, a$upper.rskov, qnorm((1+level)/2), lty=2, col="red")    }        res <- structure(list(rthetas=rs, rskovs=rskovs, lower.rtheta=lo.r, upper.rtheta=up.r, lower.rskov=lo.rskov, upper.rskov=up.rskov))    invisible(res
)}
metaLik.prof(m, 2)-> a
metaLik.prof <- function(object, param=1, level=0.95, plot=TRUE, ...){    if(class(object)!="metaLik")        stop("function designed for 'metaLik' objects")    if(length(param)>1 || param>=length(object$mle) || !is.numeric(param))        stop("'param' must be the index of one single fixed-effects component")    if (missing(param)){        param <- 1        warning("assumed confidence interval for intercept")    }    par.mle <- object$mle[param]    se.mle <- sqrt(object$vcov[param, param])    values <- seq(from=par.mle-10*se.mle, to=par.mle+10*se.mle, length=30)    rs <- rskovs <- rep(NA, length(values))    for(i in 1:length(values)){        tests <- try(metaLik.test(object, param, values[i], print=FALSE))        if(!inherits(tests, "try-error")){            rs[i] <- tests["rtheta"]            rskovs[i] <- tests["rskov"]        }    }    smooth.r <- smooth.spline(-rs, values)    smooth.rskov <- smooth.spline(-rskovs, values)    lo.r <- predict(smooth.r, x=qnorm((1-level)/2))$y    up.
r <- predict(smooth.r, x=qnorm((1+level)/2))$y    lo.rskov <- predict(smooth.rskov, x=qnorm((1-level)/2))$y    up.rskov <- predict(smooth.rskov, x=qnorm((1+level)/2))$y    par.name <- names(coef(object))[param]    if(plot){        plot(smooth.spline(values, -rs), type="l", ylim=c(min(rs, rskovs), max(rs, rskovs)), ylab="signed profile log-likelihood ratio", xlab=par.name)        lines(smooth.spline(values, -rskovs), col="red")        segments(a$lower.rtheta, min(a$rs, a$rskovs)-10, a$lower.rtheta, qnorm((1-level)/2), lty=2)        segments(a$upper.rtheta, min(a$rs, a$rskovs)-10, a$upper.rtheta, qnorm((1+level)/2), lty=2)        segments(a$lower.rskov, min(a$rs, a$rskovs)-10, a$lower.rskov, qnorm((1-level)/2), lty=2, col="red")        segments(a$upper.rskov, min(a$rs, a$rskovs)-10, a$upper.rskov, qnorm((1+level)/2), lty=2, col="red")    }        res <- structure(list(rthetas=rs, rskovs=rskovs, lower.rtheta=lo.r, upper.rtheta=up.r, lower.rskov=lo.rskov, upper.rskov=up.rskov))    invisible(res)}
metaLik.prof(m, 2)-> a
metaLik.prof <- function(object, param=1, level=0.95, plot=TRUE, ...){    if(class(object)!="metaLik")        stop("function designed for 'metaLik' objects")    if(length(param)>1 || param>=length(object$mle) || !is.numeric(param))        stop("'param' must be the index of one single fixed-effects component")    if (missing(param)){        param <- 1        warning("assumed confidence interval for intercept")    }    par.mle <- object$mle[param]    se.mle <- sqrt(object$vcov[param, param])    values <- seq(from=par.mle-10*se.mle, to=par.mle+10*se.mle, length=30)    rs <- rskovs <- rep(NA, length(values))    for(i in 1:length(values)){        tests <- try(metaLik.test(object, param, values[i], print=FALSE))        if(!inherits(tests, "try-error")){            rs[i] <- tests["rtheta"]            rskovs[i] <- tests["rskov"]        }    }    smooth.r <- smooth.spline(-rs, values)    smooth.rskov <- smooth.spline(-rskovs, values)    lo.r <- predict(smooth.r, x=qnorm((1-level)/2))$y    up.
r <- predict(smooth.r, x=qnorm((1+level)/2))$y    lo.rskov <- predict(smooth.rskov, x=qnorm((1-level)/2))$y    up.rskov <- predict(smooth.rskov, x=qnorm((1+level)/2))$y    par.name <- names(coef(object))[param]    if(plot){        plot(smooth.spline(values, -rs), type="l", ylim=c(min(rs, rskovs), max(rs, rskovs)), ylab="pivot", xlab=par.name)        lines(smooth.spline(values, -rskovs), col="red")        legend(min(values), max(rs, rskovs), c("signed LRT", "Skovgaard"), col=c("black", "red"), lty=c(1,1))        segments(a$lower.rtheta, min(a$rs, a$rskovs)-10, a$lower.rtheta, qnorm((1-level)/2), lty=2)        segments(a$upper.rtheta, min(a$rs, a$rskovs)-10, a$upper.rtheta, qnorm((1+level)/2), lty=2)        segments(a$lower.rskov, min(a$rs, a$rskovs)-10, a$lower.rskov, qnorm((1-level)/2), lty=2, col="red")        segments(a$upper.rskov, min(a$rs, a$rskovs)-10, a$upper.rskov, qnorm((1+level)/2), lty=2, col="red")    }        res <- structure(list(rthetas=rs, rskovs=rskovs, lower.rtheta=lo.r, uppe
r.rtheta=up.r, lower.rskov=lo.rskov, upper.rskov=up.rskov))    invisible(res)}
metaLik.prof(m, 2)-> a
a
confint
example(confint)
MASS:::confint
MASS:::confint.glm
help(table)
tab
metaLik.prof <- function(object, param=1, level=0.95, plot=TRUE, ...){    if(class(object)!="metaLik")        stop("function designed for 'metaLik' objects")    if(length(param)>1 || param>=length(object$mle) || !is.numeric(param))        stop("'param' must be the index of one single fixed-effects component")    if (missing(param)){        param <- 1        warning("assumed confidence interval for intercept")    }    par.mle <- object$mle[param]    se.mle <- sqrt(object$vcov[param, param])    values <- seq(from=par.mle-10*se.mle, to=par.mle+10*se.mle, length=30)    rs <- rskovs <- rep(NA, length(values))    for(i in 1:length(values)){        tests <- try(metaLik.test(object, param, values[i], print=FALSE))        if(!inherits(tests, "try-error")){            rs[i] <- tests["rtheta"]            rskovs[i] <- tests["rskov"]        }    }    smooth.r <- smooth.spline(-rs, values)    smooth.rskov <- smooth.spline(-rskovs, values)    lo.r <- predict(smooth.r, x=qnorm((1-level)/2))$y    up.
r <- predict(smooth.r, x=qnorm((1+level)/2))$y    lo.rskov <- predict(smooth.rskov, x=qnorm((1-level)/2))$y    up.rskov <- predict(smooth.rskov, x=qnorm((1+level)/2))$y    par.name <- names(coef(object))[param]    if(plot){        plot(smooth.spline(values, -rs), type="l", ylim=c(min(rs, rskovs), max(rs, rskovs)), ylab="pivot", xlab=par.name)        lines(smooth.spline(values, -rskovs), col="red")        legend(min(values), max(rs, rskovs), c("signed LRT", "Skovgaard"), col=c("black", "red"), lty=c(1,1))        segments(a$lower.rtheta, min(a$rs, a$rskovs)-10, a$lower.rtheta, qnorm((1-level)/2), lty=2)        segments(a$upper.rtheta, min(a$rs, a$rskovs)-10, a$upper.rtheta, qnorm((1+level)/2), lty=2)        segments(a$lower.rskov, min(a$rs, a$rskovs)-10, a$lower.rskov, qnorm((1-level)/2), lty=2, col="red")        segments(a$upper.rskov, min(a$rs, a$rskovs)-10, a$upper.rskov, qnorm((1+level)/2), lty=2, col="red")    }    tab <- matrix(c(lo.r, up.r, lo.rskov, up.rskov), ncol=2, byrow=TRUE)    row
names(tab) <- c("signed LRT", "Skovgaard")    colnames(tab) <- c(paste(100*(1-level/2), "%", sep=""), paste(100*(1+level)/2, "%", sep=""))    tab    res <- structure(list(rthetas=rs, rskovs=rskovs, lower.rtheta=lo.r, upper.rtheta=up.r, lower.rskov=lo.rskov, upper.rskov=up.rskov))    invisible(res)}
metaLik.prof(m, 2)-> a
a
metaLik.prof(m, 2)
metaLik.prof
metaLik.prof <- function(object, param=1, level=0.95, plot=TRUE, ...){    if(class(object)!="metaLik")        stop("function designed for 'metaLik' objects")    if(length(param)>1 || param>=length(object$mle) || !is.numeric(param))        stop("'param' must be the index of one single fixed-effects component")    if (missing(param)){        param <- 1        warning("assumed confidence interval for intercept")    }    par.mle <- object$mle[param]    se.mle <- sqrt(object$vcov[param, param])    values <- seq(from=par.mle-10*se.mle, to=par.mle+10*se.mle, length=30)    rs <- rskovs <- rep(NA, length(values))    for(i in 1:length(values)){        tests <- try(metaLik.test(object, param, values[i], print=FALSE))        if(!inherits(tests, "try-error")){            rs[i] <- tests["rtheta"]            rskovs[i] <- tests["rskov"]        }    }    smooth.r <- smooth.spline(-rs, values)    smooth.rskov <- smooth.spline(-rskovs, values)    lo.r <- predict(smooth.r, x=qnorm((1-level)/2))$y    up.
r <- predict(smooth.r, x=qnorm((1+level)/2))$y    lo.rskov <- predict(smooth.rskov, x=qnorm((1-level)/2))$y    up.rskov <- predict(smooth.rskov, x=qnorm((1+level)/2))$y    par.name <- names(coef(object))[param]    if(plot){        plot(smooth.spline(values, -rs), type="l", ylim=c(min(rs, rskovs), max(rs, rskovs)), ylab="pivot", xlab=par.name)        lines(smooth.spline(values, -rskovs), col="red")        legend(min(values), max(rs, rskovs), c("signed LRT", "Skovgaard"), col=c("black", "red"), lty=c(1,1))        segments(a$lower.rtheta, min(a$rs, a$rskovs)-10, a$lower.rtheta, qnorm((1-level)/2), lty=2)        segments(a$upper.rtheta, min(a$rs, a$rskovs)-10, a$upper.rtheta, qnorm((1+level)/2), lty=2)        segments(a$lower.rskov, min(a$rs, a$rskovs)-10, a$lower.rskov, qnorm((1-level)/2), lty=2, col="red")        segments(a$upper.rskov, min(a$rs, a$rskovs)-10, a$upper.rskov, qnorm((1+level)/2), lty=2, col="red")    }    tab <- matrix(c(lo.r, up.r, lo.rskov, up.rskov), ncol=2, byrow=TRUE)    row
names(tab) <- c("signed LRT", "Skovgaard")    colnames(tab) <- c(paste(100*(1-level/2), "%", sep=""), paste(100*(1+level)/2, "%", sep=""))    print(tab)    res <- structure(list(rthetas=rs, rskovs=rskovs, lower.rtheta=lo.r, upper.rtheta=up.r, lower.rskov=lo.rskov, upper.rskov=up.rskov))    invisible(res)}
metaLik.prof
metaLik.prof(m, 2)
metaLik.prof
(1-0.95)/2
100*(1-0.95)/2
metaLik.prof <- function(object, param=1, level=0.95, plot=TRUE, ...){    if(class(object)!="metaLik")        stop("function designed for 'metaLik' objects")    if(length(param)>1 || param>=length(object$mle) || !is.numeric(param))        stop("'param' must be the index of one single fixed-effects component")    if (missing(param)){        param <- 1        warning("assumed confidence interval for intercept")    }    par.mle <- object$mle[param]    se.mle <- sqrt(object$vcov[param, param])    values <- seq(from=par.mle-10*se.mle, to=par.mle+10*se.mle, length=30)    rs <- rskovs <- rep(NA, length(values))    for(i in 1:length(values)){        tests <- try(metaLik.test(object, param, values[i], print=FALSE))        if(!inherits(tests, "try-error")){            rs[i] <- tests["rtheta"]            rskovs[i] <- tests["rskov"]        }    }    smooth.r <- smooth.spline(-rs, values)    smooth.rskov <- smooth.spline(-rskovs, values)    lo.r <- predict(smooth.r, x=qnorm((1-level)/2))$y    up.
r <- predict(smooth.r, x=qnorm((1+level)/2))$y    lo.rskov <- predict(smooth.rskov, x=qnorm((1-level)/2))$y    up.rskov <- predict(smooth.rskov, x=qnorm((1+level)/2))$y    par.name <- names(coef(object))[param]    if(plot){        plot(smooth.spline(values, -rs), type="l", ylim=c(min(rs, rskovs), max(rs, rskovs)), ylab="pivot", xlab=par.name)        lines(smooth.spline(values, -rskovs), col="red")        legend(min(values), max(rs, rskovs), c("signed LRT", "Skovgaard"), col=c("black", "red"), lty=c(1,1))        segments(a$lower.rtheta, min(a$rs, a$rskovs)-10, a$lower.rtheta, qnorm((1-level)/2), lty=2)        segments(a$upper.rtheta, min(a$rs, a$rskovs)-10, a$upper.rtheta, qnorm((1+level)/2), lty=2)        segments(a$lower.rskov, min(a$rs, a$rskovs)-10, a$lower.rskov, qnorm((1-level)/2), lty=2, col="red")        segments(a$upper.rskov, min(a$rs, a$rskovs)-10, a$upper.rskov, qnorm((1+level)/2), lty=2, col="red")    }    tab <- matrix(c(lo.r, up.r, lo.rskov, up.rskov), ncol=2, byrow=TRUE)    row
names(tab) <- c("signed LRT", "Skovgaard")    colnames(tab) <- c(paste(100*(1-level)/2, "%", sep=""), paste(100*(1+level)/2, "%", sep=""))    print(tab)    res <- structure(list(rthetas=rs, rskovs=rskovs, lower.rtheta=lo.r, upper.rtheta=up.r, lower.rskov=lo.rskov, upper.rskov=up.rskov))    invisible(res)}
metaLik.prof(m, 2)
metaLik.prof(m, 1)
metaLik.prof(m, 2)
metaLik.prof(m, 1)
metaLik.prof(m, 3)
metaLik.prof(m, 1)
metaLik.prof <- function(object, param=1, level=0.95, plot=TRUE, ...){    if(class(object)!="metaLik")        stop("function designed for 'metaLik' objects")    if(length(param)>1 || param>=length(object$mle) || !is.numeric(param))        stop("'param' must be the index of one single fixed-effects component")    if (missing(param)){        param <- 1        warning("assumed confidence interval for intercept")    }    par.mle <- object$mle[param]    se.mle <- sqrt(object$vcov[param, param])    values <- seq(from=par.mle-10*se.mle, to=par.mle+10*se.mle, length=30)    rs <- rskovs <- rep(NA, length(values))    for(i in 1:length(values)){        tests <- try(metaLik.test(object, param, values[i], print=FALSE))        if(!inherits(tests, "try-error")){            rs[i] <- tests["rtheta"]            rskovs[i] <- tests["rskov"]        }    }    smooth.r <- smooth.spline(-rs, values)    smooth.rskov <- smooth.spline(-rskovs, values)    lo.r <- predict(smooth.r, x=qnorm((1-level)/2))$y    up.
r <- predict(smooth.r, x=qnorm((1+level)/2))$y    lo.rskov <- predict(smooth.rskov, x=qnorm((1-level)/2))$y    up.rskov <- predict(smooth.rskov, x=qnorm((1+level)/2))$y    par.name <- names(coef(object))[param]    if(plot){        plot(smooth.spline(values, -rs), type="l", ylim=c(min(rs, rskovs), max(rs, rskovs)), ylab="pivot", xlab=par.name)        lines(smooth.spline(values, -rskovs), col="red")        legend(min(values), max(rs, rskovs), c("signed LRT", "Skovgaard"), col=c("black", "red"), lty=c(1,1))        segments(a$lo.r, min(a$rs, a$rskovs)-10, a$lo.r, qnorm((1-level)/2), lty=2)        segments(a$up.r, min(a$rs, a$rskovs)-10, a$up.r, qnorm((1+level)/2), lty=2)        segments(a$lo.rskov, min(a$rs, a$rskovs)-10, a$lo.rskov, qnorm((1-level)/2), lty=2, col="red")        segments(a$up.rskov, min(a$rs, a$rskovs)-10, a$up.rskov, qnorm((1+level)/2), lty=2, col="red")    }    tab <- matrix(c(lo.r, up.r, lo.rskov, up.rskov), ncol=2, byrow=TRUE)    rownames(tab) <- c("signed LRT", "Skovgaard")
   colnames(tab) <- c(paste(100*(1-level)/2, "%", sep=""), paste(100*(1+level)/2, "%", sep=""))    print(tab)    res <- structure(list(rthetas=rs, rskovs=rskovs, lower.rtheta=lo.r, upper.rtheta=up.r, lower.rskov=lo.rskov, upper.rskov=up.rskov))    invisible(res)}
metaLik.prof(m, 2)
metaLik.prof <- function(object, param=1, level=0.95, plot=TRUE, ...){    if(class(object)!="metaLik")        stop("function designed for 'metaLik' objects")    if(length(param)>1 || param>=length(object$mle) || !is.numeric(param))        stop("'param' must be the index of one single fixed-effects component")    if (missing(param)){        param <- 1        warning("assumed confidence interval for intercept")    }    par.mle <- object$mle[param]    se.mle <- sqrt(object$vcov[param, param])    values <- seq(from=par.mle-10*se.mle, to=par.mle+10*se.mle, length=30)    rs <- rskovs <- rep(NA, length(values))    for(i in 1:length(values)){        tests <- try(metaLik.test(object, param, values[i], print=FALSE))        if(!inherits(tests, "try-error")){            rs[i] <- tests["rtheta"]            rskovs[i] <- tests["rskov"]        }    }    smooth.r <- smooth.spline(-rs, values)    smooth.rskov <- smooth.spline(-rskovs, values)    lo.r <- predict(smooth.r, x=qnorm((1-level)/2))$y    up.
r <- predict(smooth.r, x=qnorm((1+level)/2))$y    lo.rskov <- predict(smooth.rskov, x=qnorm((1-level)/2))$y    up.rskov <- predict(smooth.rskov, x=qnorm((1+level)/2))$y    par.name <- names(coef(object))[param]    if(plot){        plot(smooth.spline(values, -rs), type="l", ylim=c(min(rs, rskovs), max(rs, rskovs)), ylab="pivot", xlab=par.name)        lines(smooth.spline(values, -rskovs), col="red")        legend(min(values), max(rs, rskovs), c("signed LRT", "Skovgaard"), col=c("black", "red"), lty=c(1,1))        segments(lo.r, min(rs, rskovs)-10, lo.r, qnorm((1-level)/2), lty=2)        segments(up.r, min(rs, rskovs)-10, up.r, qnorm((1+level)/2), lty=2)        segments(lo.rskov, min(rs, rskovs)-10, lo.rskov, qnorm((1-level)/2), lty=2, col="red")        segments(up.rskov, min(rs, rskovs)-10, up.rskov, qnorm((1+level)/2), lty=2, col="red")    }    tab <- matrix(c(lo.r, up.r, lo.rskov, up.rskov), ncol=2, byrow=TRUE)    rownames(tab) <- c("signed LRT", "Skovgaard")    colnames(tab) <- c(paste(100*
(1-level)/2, "%", sep=""), paste(100*(1+level)/2, "%", sep=""))    print(tab)    res <- structure(list(rthetas=rs, rskovs=rskovs, lower.rtheta=lo.r, upper.rtheta=up.r, lower.rskov=lo.rskov, upper.rskov=up.rskov))    invisible(res)}
metaLik.prof(m, 2)
metaLik.prof(m, 1)
library(metaLik)
help(metaLik.test)
example(metaLik.test)
example(metaLik.prof)
help(metaLik.prof)
vaccine
vaccine <- data.frame(y=y, latitude=lat, year=year, sigma2=sigma2)
vaccine <- data.frame(y=vaccine$y, latitude=vaccine$lat, year=vaccine$year, sigma2=vaccine$sigma2)
vaccine
save(vaccine, file="~/Desktop/metaLik/data/vaccine.RData")
library(metaLik)
example(metaLik)
library(metaLik)
example(metaLik)
library(metaLik)
example(metaLik)
example(metaLik.test)
example(metaLik.prof)
library(polycor)
lm
glm
library(nlm)
library(nlme)
nlme
help(nlme)
library(mr)
help(mr)
mrbn
library(nlme)
help(nlme)
library(gcmr)
help(gcmr)
gcmr
lm
lm.fit
glm
glm.fit
help(glm)
glm
method
identical
args(glm)
help(glm)
glm.fit
library(nlme)
nlme
nlme:::nlme.fit
nlme
library(MASS)
polr
gcmr
args(gcmr)
glm
glm.fit
library(gcmr)
example(gcmr)
gcmr(y~., data=polio, marginal=nb.marg(), vcov=arma.cor(2,1), options=list(seed=71271, nrep=100))->a
library(xtable)
xtable(coef(a))
coef(a)
xtable(cbind(coef(a), se(a))
)
a
gcmr.fit(polio[,2], polio$y,marginal = nb.marg(), vcov = arma.cor(2, #
    1), options = list(seed = 71271, nrep = 100))-> b
b
se
parvar
se
parvar
se
help(gcmr)
library(BradleyTerry2)
help(BTm)
help(vcov)
vcov.gls
vcov
help(vcov)
vcov.glm
vcov.polr
MASS:::vcov.polr
MASS:::vcov.gls
MASS:::vcov.glm
MASS:::vcov.nls
MASS:::vcov.rlm
vcov
vcovHAC
library(gnm)
help(residuals)
help(residuals.gnm)
help(profile.gnm)
b
names(b)
b$vcov
library(mr)
example(mr)
help(mr)
## Warning: Likelihood is approximated using only a limited number of Monte Carlo replications.#
## Polio data. Marginal negative binomial model with ARMA(2,1) errors.#
data(polio)#
mr(x=x.polio,y=y.polio,marginal=mrnb(),vcov=mrarma(2,1),options=list(seed=71271, nrep=100))
data(polio)tm <- time(y.polio)fr.x <- frequency(y.polio)p1 <- format(floor(zapsmall(tm)))t2 <- 1 + round(fr.x * ((tm + 0.001)%%1))times <- paste(month.abb[t2], p1, sep = " ")polio.names <- c("y", "t*10^(-3)", "cos(2*pi*t/12)", "sin(2*pi*t/12)", "cos(2*pi*t/6)",  "sin(2*pi*t/6)")polio <- data.frame(cbind(y.polio, x.polio[,-1]))colnames(polio) <- polio.namesrownames(polio) <- times
save(polio, file="polio.RData")
example(profile.gcmr)
profile.gcmr
cor
cor.gcmr
